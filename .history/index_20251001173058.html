<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Circle Packing Export</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 2rem; }
    #viz { border: 1px solid #ccc; }
    button { margin-top: 1rem; padding: 0.5rem 1rem; font-size: 1rem; }
  </style>
</head>
<body>
 
  <svg id="viz" width="700" height="700"></svg>
  <br>
  <button id="downloadBtn">Download SVG</button>

  <script>
    // === Animation Configuration ===
    const CONFIG = {
      // Ball settings
      BALL_COUNT: 10,
      BALL_SIZE_MULTIPLIER: 0.5, // Multiplier for ball sizes (1.0 = original)
      
      // Animation timing
      BALL_APPEAR_DELAY: 140, // ms between ball appearances
      FINAL_SETTLEMENT_TIME: 4000, // ms for final settlement phase
      
      // Force simulation parameters
      CHARGE_STRENGTH: -50, // Repulsion between balls
      PACK_FORCE_STRENGTH: 0.5, // Strength of pack force (0.1-0.5)
      COLLISION_PADDING: 0.00001, // Extra padding around balls for collision
      ALPHA_DECAY: 0.00002, // How fast simulation slows down
      
      // Visual settings
      STROKE_WIDTH: 2,
      LINE_WIDTH: 0.5,
      LINE_OPACITY: 0.3,
      STROKE_COLOR: "#0A61B5",
      LINE_COLOR: "#0A61B5",
      
      // Canvas settings
      CANVAS_SIZE: 700,
      CENTER_X: 350, // Updated for 700px canvas
      CENTER_Y: 350, // Updated for 700px canvas
      
      // Performance settings
      TARGET_FPS: 60, // Target frames per second
      FRAME_SKIP: 1, // Update every N frames (1 = every frame)
      ENABLE_LINES: true, // Toggle connecting lines for performance
      MAX_LINES: 5000, // Maximum number of lines to draw
      
      // Ball sizing and spacing
      FIXED_BALL_RADIUS: 15, // Fixed radius for all balls
      BALL_PADDING: 1 // Padding between balls
    };

    // === Generate packed circles with variable sizes and padding control ===
    // Create data with random values for different ball sizes
    const data = { children: Array.from({ length: CONFIG.BALL_COUNT }, () => ({ value: Math.random() })) };

    // Use a reasonable packing size that scales with ball count
    const baseSize = Math.min(CONFIG.CANVAS_SIZE * 0.8, 500);
    const packingSize = Math.max(baseSize * Math.sqrt(CONFIG.BALL_COUNT / 60), 200);
    
    const pack = d3.pack()
      .size([packingSize, packingSize])
      .padding(CONFIG.BALL_PADDING); // Use padding from config

    const root = d3.hierarchy(data).sum(d => d.value);
    const nodes = pack(root).leaves();
    
    // Apply size multiplier to control overall ball sizes
    nodes.forEach(node => {
      node.r *= CONFIG.BALL_SIZE_MULTIPLIER;
    });
    
    // Center the packed circles in the canvas
    const offsetX = (CONFIG.CANVAS_SIZE - packingSize) / 2;
    const offsetY = (CONFIG.CANVAS_SIZE - packingSize) / 2;
    
    nodes.forEach(node => {
      node.x += offsetX;
      node.y += offsetY;
    });

    const svg = d3.select("#viz");

    // === Animation variables ===
    let currentNodes = [];
    let simulation = null;
    let circles = null;
    let lines = null;
    let frameCount = 0;
    let lastFrameTime = 0;
    let animationId = null;

    // === Force simulation setup ===
    function createSimulation(nodes) {
      return d3.forceSimulation(nodes)
        .force("charge", d3.forceManyBody().strength(CONFIG.CHARGE_STRENGTH))
        .force("center", d3.forceCenter(CONFIG.CENTER_X, CONFIG.CENTER_Y))
        .force("collision", d3.forceCollide().radius(d => d.r + CONFIG.COLLISION_PADDING))
        .force("pack", packForce(nodes))
        .alphaDecay(CONFIG.ALPHA_DECAY) // Slower decay for more settling time
        .on("tick", updateVisualization)
        .velocityDecay(0.4); // Add velocity decay for smoother animation
    }

    // === Custom force to move toward packed positions ===
    function packForce(nodes) {
      return function() {
        nodes.forEach(node => {
          if (node.targetX !== undefined && node.targetY !== undefined) {
            const dx = node.targetX - node.x;
            const dy = node.targetY - node.y;
            node.vx += dx * CONFIG.PACK_FORCE_STRENGTH;
            node.vy += dy * CONFIG.PACK_FORCE_STRENGTH;
          }
        });
      };
    }

    // === Optimized visualization update with frame rate limiting ===
    function updateVisualization() {
      frameCount++;
      
      // Skip frames for better performance
      if (frameCount % CONFIG.FRAME_SKIP !== 0) return;
      
      const now = performance.now();
      const deltaTime = now - lastFrameTime;
      
      // Target 60 FPS = ~16.67ms per frame
      if (deltaTime < 1000 / CONFIG.TARGET_FPS) return;
      
      lastFrameTime = now;
      
      // Update circles (always needed)
      if (circles) {
        circles
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);
      }
      
      // Update lines only if enabled and not too many
      if (CONFIG.ENABLE_LINES && lines && lines.size() <= CONFIG.MAX_LINES) {
        lines
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);
      }
    }

    // === Add new ball and trigger simulation ===
    function addBall() {
      if (currentNodes.length >= nodes.length) {
        // All balls added, start final settlement phase
        startFinalSettlement();
        return;
      }

      // Add new node at center with target packed position
      const newNode = {
        ...nodes[currentNodes.length],
        x: CONFIG.CENTER_X, // start at center
        y: CONFIG.CENTER_Y, // start at center
        targetX: nodes[currentNodes.length].x, // packed position
        targetY: nodes[currentNodes.length].y, // packed position
        vx: 0,
        vy: 0
      };
      currentNodes.push(newNode);

      // Update target positions for all existing nodes to their packed positions
      currentNodes.forEach((node, i) => {
        node.targetX = nodes[i].x;
        node.targetY = nodes[i].y;
      });

      // Update circles
      circles = svg.selectAll("circle")
        .data(currentNodes)
        .join("circle")
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
        .attr("r", d => d.r)
        .attr("fill", "none")
        .attr("stroke", CONFIG.STROKE_COLOR)
        .attr("stroke-width", CONFIG.STROKE_WIDTH);

      // Update lines (connect new ball to all existing balls) - only if enabled
      if (CONFIG.ENABLE_LINES) {
        const links = [];
        const maxLinks = Math.min(CONFIG.MAX_LINES, (currentNodes.length * (currentNodes.length - 1)) / 2);
        
        // Create links more efficiently
        for (let i = 0; i < currentNodes.length && links.length < maxLinks; i++) {
          for (let j = i + 1; j < currentNodes.length && links.length < maxLinks; j++) {
            links.push({ source: currentNodes[i], target: currentNodes[j] });
          }
        }

        lines = svg.selectAll("line")
          .data(links)
          .join("line")
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y)
          .attr("stroke", CONFIG.LINE_COLOR)
          .attr("stroke-width", CONFIG.LINE_WIDTH)
          .attr("opacity", CONFIG.LINE_OPACITY);
      }

      // Create new simulation with updated nodes
      if (simulation) simulation.stop();
      simulation = createSimulation(currentNodes);
      
      // Run simulation for a bit, then add next ball
      simulation.alpha(1).restart();
      
      setTimeout(() => {
        simulation.stop();
        addBall();
      }, CONFIG.BALL_APPEAR_DELAY);
    }

    // === Final settlement phase ===
    function startFinalSettlement() {
      console.log("Starting final settlement phase...");
      
      // Create final simulation with all nodes
      if (simulation) simulation.stop();
      simulation = createSimulation(currentNodes);
      
      // Run for much longer with stronger pack force
      simulation.alpha(1).restart();
      
      // Let it run for configured time for final settlement
      setTimeout(() => {
        if (simulation) simulation.stop();
        console.log("Final settlement complete!");
      }, CONFIG.FINAL_SETTLEMENT_TIME);
    }

    // === Performance monitoring ===
    function logPerformance() {
      const fps = Math.round(1000 / (performance.now() - lastFrameTime));
      console.log(`FPS: ${fps}, Balls: ${currentNodes.length}, Lines: ${lines ? lines.size() : 0}`);
    }

    // === Start the animation ===
    addBall();
    
    // Log performance every 2 seconds
    setInterval(logPerformance, 2000);

    // === Download logic ===
    document.getElementById("downloadBtn").addEventListener("click", () => {
      const serializer = new XMLSerializer();
      const svgNode = document.getElementById("viz");
      const source = serializer.serializeToString(svgNode);

      const blob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(blob);

      const link = document.createElement("a");
      link.href = url;
      link.download = "circle-packing.svg";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>