<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Circle Packing Export</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 2rem; }
    #viz { border: 1px solid #ccc; }
    button { margin-top: 1rem; padding: 0.5rem 1rem; font-size: 1rem; }
  </style>
</head>
<body>
 
  <svg id="viz"></svg>
  <br>
  <button id="downloadBtn">Download SVG</button>

  <script>
    // === Animation Configuration ===
    const CONFIG = {
      // === LEFT SIDE (MAIN ANIMATION) BALL SETTINGS ===
      BALL_COUNT: 60, // Number of balls in main animation
      BALL_SIZE_MULTIPLIER: 1, // Multiplier for ball sizes (1.0 = original)
      
      // Animation timing
      BALL_APPEAR_DELAY: 10, // ms between ball appearances
      FINAL_SETTLEMENT_TIME:6000, // ms for final settlement phase
      
      // Force simulation parameters (Mike Bostock balanced approach)
      CHARGE_STRENGTH: -80, // Moderate repulsion between balls
      PACK_FORCE_STRENGTH: 0.1, // Very weak pack force (reduced to prevent center crashing)
      COLLISION_PADDING: 8, // Strong collision padding for separation
      ALPHA_DECAY: 0.05, // Very slow decay for gentle settling
      
      // Visual settings
      STROKE_WIDTH: 2,
      LINE_WIDTH: 0.5,
      LINE_OPACITY: 0.3,
      STROKE_COLOR: "#0A61B5",
      LINE_COLOR: "#0A61B5",
      
      // Canvas settings (will be overridden by responsive system)
      CANVAS_SIZE: 1400, // Reference size for scaling calculations
      CENTER_X: 350, // Reference left side center (will be replaced by responsive)
      CENTER_Y: 320, // Reference center Y (will be replaced by responsive)
      
      // === LEFT SIDE (MAIN ANIMATION) SETTINGS ===
      // Main animation uses the existing CONFIG settings above
      
      // === RIGHT SIDE (SIX CLUSTERS) SETTINGS ===
      NUM_CLUSTERS: 6, // Number of clusters on right side
      BALLS_PER_CLUSTER: 6, // Fixed number of balls per cluster (all same)
      RIGHT_CLUSTER_BALL_SIZE: 12, // Fixed size for all right-side balls
      CLUSTER_RADIUS: 200, // Distance from center for cluster centers
      CLUSTER_PACK_SIZE: 120, // Size for individual cluster packing
      RIGHT_SIDE_CENTER_X: 1050, // Reference right side center (will be replaced by responsive)
      RIGHT_SIDE_CENTER_Y: 320, // Reference right side center Y (will be replaced by responsive)
      
      // Performance settings
      TARGET_FPS: 60, // Target frames per second
      FRAME_SKIP: 1, // Update every N frames (1 = every frame)
      ENABLE_LINES: true, // Toggle: true = show connecting lines, false = hide lines
      MAX_LINES: 500, // Maximum number of lines to draw
      
      // Ball sizing and spacing
      USE_FIXED_SIZE: false, // Toggle: true = all balls same size, false = variable sizes
      FIXED_BALL_RADIUS: 8, // Fixed radius for all balls (when USE_FIXED_SIZE = true)
      MIN_BALL_RADIUS: 1, // Minimum ball radius (when USE_FIXED_SIZE = false)
      MAX_BALL_RADIUS: 205, // Maximum ball radius (when USE_FIXED_SIZE = false)
      BALL_PADDING: 10, // Padding between balls
      
      // === LEFT SIDE (MAIN ANIMATION) SIZE DISTRIBUTION SETTINGS ===
      USE_ABSOLUTE_SIZING: true, // Toggle: true = absolute sizes, false = packed sizes
      LARGE_BALL_COUNT: 7, // Number of large balls in main animation
      LARGE_BALL_MIN_RADIUS: 10, // Minimum radius for large balls in main animation
      LARGE_BALL_MAX_RADIUS: 120, // Maximum radius for large balls in main animation
      SMALL_BALL_MIN_RADIUS: 5, // Minimum radius for small balls in main animation
      SMALL_BALL_MAX_RADIUS: 15, // Maximum radius for small balls in main animation
    };

    // === RESPONSIVE DETECTION SYSTEM (Phase 1) ===
    
    // Tailwind CSS breakpoints
    const BREAKPOINTS = {
      sm: 640,   // mobile landscape/small tablets
      md: 768,   // tablets
      lg: 1024,  // small laptops
      xl: 1280,  // desktops
      '2xl': 1536 // large screens
    };
    
    // Container max-width constraints
    const CONTAINER_MAX_WIDTH = 1600; // Increased to allow 2xl breakpoint (1536px) to trigger
    
    // Current responsive state
    let currentBreakpoint = 'xl'; // Default to desktop
    let viewportWidth = window.innerWidth;
    let viewportHeight = window.innerHeight;
    let containerWidth = Math.min(viewportWidth, CONTAINER_MAX_WIDTH);
    
    // Responsive detection functions
    function getCurrentBreakpoint(width) {
      if (width < BREAKPOINTS.sm) return 'xs';
      if (width < BREAKPOINTS.md) return 'sm';
      if (width < BREAKPOINTS.lg) return 'md';
      if (width < BREAKPOINTS.xl) return 'lg';
      if (width < BREAKPOINTS['2xl']) return 'xl';
      return '2xl';
    }
    
    function updateResponsiveState() {
      const newViewportWidth = window.innerWidth;
      const newViewportHeight = window.innerHeight;
      const newContainerWidth = Math.min(newViewportWidth, CONTAINER_MAX_WIDTH);
      const newBreakpoint = getCurrentBreakpoint(newContainerWidth);
      
      const breakpointChanged = newBreakpoint !== currentBreakpoint;
      const sizeChanged = newViewportWidth !== viewportWidth || newViewportHeight !== viewportHeight;
      
      viewportWidth = newViewportWidth;
      viewportHeight = newViewportHeight;
      containerWidth = newContainerWidth;
      currentBreakpoint = newBreakpoint;
      
      // Debug logging
      console.log(`📱 Responsive Update:`, {
        breakpoint: currentBreakpoint,
        viewport: `${viewportWidth}x${viewportHeight}`,
        container: containerWidth,
        changed: { breakpoint: breakpointChanged, size: sizeChanged }
      });
      
      // Trigger responsive updates if needed
      if (breakpointChanged || sizeChanged) {
        handleResponsiveChange(breakpointChanged, sizeChanged);
      }
      
      return { breakpointChanged, sizeChanged };
    }
    
    function handleResponsiveChange(breakpointChanged, sizeChanged) {
      console.log(`🔄 Handling responsive change:`, { breakpointChanged, sizeChanged });
      
      // Phase 1: Just logging - future phases will implement actual responsive behavior
      if (breakpointChanged) {
        console.log(`📊 Breakpoint changed to: ${currentBreakpoint}`);
      }
      
      if (sizeChanged) {
        console.log(`📏 Size changed: ${viewportWidth}x${viewportHeight}`);
      }
      
      // Phase 2: Update canvas dimensions on any responsive change
      if (breakpointChanged || sizeChanged) {
        currentCanvasDimensions = updateCanvasDimensions();
        console.log(`🎯 Canvas updated for ${currentBreakpoint}: ${currentCanvasDimensions.width}x${currentCanvasDimensions.height} (${currentCanvasDimensions.layout})`);
        
        // Phase 3: Update layout parameters after canvas dimensions change
        currentLayoutParams = updateResponsiveLayout();
        console.log(`🎯 Layout parameters updated for ${currentBreakpoint}`);
      }
    }
    
    // Set up ResizeObserver for efficient viewport monitoring
    let resizeObserver;
    function setupResponsiveMonitoring() {
      // Initial state
      updateResponsiveState();
      
      // Set up ResizeObserver for container
      const container = document.body;
      if (window.ResizeObserver) {
        resizeObserver = new ResizeObserver(entries => {
          for (let entry of entries) {
            updateResponsiveState();
          }
        });
        resizeObserver.observe(container);
      } else {
        // Fallback to window resize for older browsers
        window.addEventListener('resize', updateResponsiveState);
      }
      
      console.log(`🎯 Responsive monitoring initialized - Current: ${currentBreakpoint} (${containerWidth}px)`);
    }
    
    // === RESPONSIVE CANVAS SIZING SYSTEM (Phase 2) ===
    
    // Responsive canvas configuration
    const RESPONSIVE_CONFIG = {
      // Aspect ratio for canvas (width/height)
      aspectRatio: 1400 / 700, // 2:1 ratio from original
      
      // Breakpoint-specific configurations
      breakpoints: {
        xs: { 
          maxWidth: '100vw', 
          maxHeight: '60vh',
          padding: 20,
          layout: 'stacked', // Vertical stacking for mobile
          // Animation center positioning
          centerYOffset: 0, // Y offset for animation centerpoints (positive = down, negative = up)
          // Stacked layout positioning (only applies when layout = 'stacked')
          leftAnimationYOffset: 0, // Y offset for left animation in stacked layout
          rightAnimationYOffset: 0, // Y offset for right animation in stacked layout
          leftTitleYOffset: 0, // Y offset for left title in stacked layout
          rightTitleYOffset: 0, // Y offset for right title in stacked layout
          // Text positioning
          textOffset: 0.8, // Multiplier for text Y position relative to center
          // Left-side animation sizing
          leftBallSizeMultiplier: 0.6, // Multiplier for all left-side balls
          leftLargeBallMultiplier: 1.8, // Multiplier for large balls vs small balls
          // Right-side cluster sizing
          clusterBallSize: 8, // Size of individual cluster balls
          clusterRadius: 80, // Distance from center for cluster centers
          clusterPackSize: 60, // Size for individual cluster packing
        },
        sm: { 
          maxWidth: '100vw', 
          maxHeight: '70vh',
          padding: 30,
          layout: 'stacked',
          // Animation center positioning
          centerYOffset: -10, // Y offset for animation centerpoints (positive = down, negative = up)
          // Stacked layout positioning (only applies when layout = 'stacked')
          leftAnimationYOffset: 0, // Y offset for left animation in stacked layout
          rightAnimationYOffset: 0, // Y offset for right animation in stacked layout
          leftTitleYOffset: 0, // Y offset for left title in stacked layout
          rightTitleYOffset: 0, // Y offset for right title in stacked layout
          // Text positioning
          textOffset: 0.4,
          // Left-side animation sizing
          leftBallSizeMultiplier: 0.7,
          leftLargeBallMultiplier: 0.5,
          // Right-side cluster sizing
          clusterBallSize: 4,
          clusterRadius: 200,
          clusterPackSize: 100,
        },
        md: { 
          maxWidth: '95vw', 
          maxHeight: '75vh',
          padding: 40,
          layout: 'hybrid', // Hybrid layout for tablets
          // Animation center positioning
          centerYOffset: 0, // Y offset for animation centerpoints (positive = down, negative = up)
          // Text positioning
          textOffset: 0.5, // 25% of canvas height below center
          // Left-side animation sizing
          leftBallSizeMultiplier: 0.8,
          leftLargeBallMultiplier: 0.7,
          // Right-side cluster sizing
          clusterBallSize: 7,
          clusterRadius: 180,
          clusterPackSize: 120,
        },
        lg: { 
          maxWidth: '90vw', 
          maxHeight: '80vh',
          padding: 50,
          layout: 'dual', // Side-by-side for laptops
          // Animation center positioning
          centerYOffset: 0, // Y offset for animation centerpoints (positive = down, negative = up)
          // Text positioning
          textOffset: 0.43, // 25% of canvas height below center
          // Left-side animation sizing
          leftBallSizeMultiplier: 0.7,
          leftLargeBallMultiplier: 0.8,
          // Right-side cluster sizing
          clusterBallSize: 8,
          clusterRadius: 180,
          clusterPackSize: 110,
        },
        xl: { 
          maxWidth: '85vw', 
          maxHeight: '85vh',
          padding: 60,
          layout: 'dual',
          // Animation center positioning
          centerYOffset: 0, // Y offset for animation centerpoints (positive = down, negative = up)
          // Text positioning
          textOffset: 0.42, // 25% of canvas height below center
          // Left-side animation sizing
          leftBallSizeMultiplier: 1.0,
          leftLargeBallMultiplier: 0.7,
          // Right-side cluster sizing
          clusterBallSize: 8,
          clusterRadius: 180,
          clusterPackSize: 100,
        },
        '2xl': { 
          maxWidth: CONTAINER_MAX_WIDTH,
          maxHeight: '90vh',
          padding: 80,
          layout: 'dual',
          // Animation center positioning
          centerYOffset: 0, // Y offset for animation centerpoints (positive = down, negative = up)
          // Text positioning
          textOffset: 0.42, // 25% of canvas height below center
          // Left-side animation sizing
          leftBallSizeMultiplier: 1.1,
          leftLargeBallMultiplier: 1,
          // Right-side cluster sizing
          clusterBallSize: 10, // Slightly larger for 2xl screens
          clusterRadius: 180, // Increased for larger screens
          clusterPackSize: 100, // Increased for larger screens
        }
      }
    };
    
    // Calculate responsive canvas dimensions
    function calculateCanvasDimensions() {
      const config = RESPONSIVE_CONFIG.breakpoints[currentBreakpoint];
      const availableWidth = viewportWidth - (config.padding * 2);
      const availableHeight = viewportHeight - (config.padding * 2);
      
      // Calculate dimensions based on aspect ratio and available space
      let canvasWidth, canvasHeight;
      
      if (config.layout === 'stacked') {
        // For mobile: use full width, calculate height based on content
        canvasWidth = Math.min(availableWidth, 600); // Max 600px on mobile
        canvasHeight = Math.min(availableHeight * 0.8, 800); // 80% of available height, max 800px
      } else {
        // For desktop: maintain aspect ratio
        const widthBasedHeight = availableWidth / RESPONSIVE_CONFIG.aspectRatio;
        const heightBasedWidth = availableHeight * RESPONSIVE_CONFIG.aspectRatio;
        
        if (widthBasedHeight <= availableHeight) {
          canvasWidth = availableWidth;
          canvasHeight = widthBasedHeight;
        } else {
          canvasWidth = heightBasedWidth;
          canvasHeight = availableHeight;
        }
        
        // Apply max width constraint for 2xl
        if (currentBreakpoint === '2xl') {
          canvasWidth = Math.min(canvasWidth, CONTAINER_MAX_WIDTH);
          canvasHeight = canvasWidth / RESPONSIVE_CONFIG.aspectRatio;
        }
      }
      
      return {
        width: Math.round(canvasWidth),
        height: Math.round(canvasHeight),
        layout: config.layout,
        padding: config.padding
      };
    }
    
    // Update SVG dimensions responsively
    function updateCanvasDimensions() {
      const dimensions = calculateCanvasDimensions();
      
      // Update SVG dimensions
      const svg = d3.select("#viz");
      svg
        .attr("width", dimensions.width)
        .attr("height", dimensions.height);
      
      // Update debug info
      console.log(`📐 Canvas dimensions updated:`, {
        breakpoint: currentBreakpoint,
        dimensions: `${dimensions.width}x${dimensions.height}`,
        layout: dimensions.layout,
        padding: dimensions.padding
      });
      
      return dimensions;
    }
    
    // Initial canvas sizing
    let currentCanvasDimensions = updateCanvasDimensions();
    
    // Add visual debug indicator (Phase 1 & 2 testing)
    function addResponsiveDebugIndicator() {
      const debugDiv = document.createElement('div');
      debugDiv.id = 'responsive-debug';
      debugDiv.style.cssText = `
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-family: monospace;
        font-size: 12px;
        z-index: 1000;
        pointer-events: none;
      `;
      document.body.appendChild(debugDiv);
      
      // Update debug indicator
      function updateDebugIndicator() {
        const canvasInfo = currentCanvasDimensions ? 
          `${currentCanvasDimensions.width}x${currentCanvasDimensions.height}` : 'calculating...';
        debugDiv.textContent = `${currentBreakpoint} | ${canvasInfo} | ${viewportWidth}x${viewportHeight}`;
      }
      
      // Update on responsive changes
      const originalHandleChange = handleResponsiveChange;
      handleResponsiveChange = function(breakpointChanged, sizeChanged) {
        originalHandleChange(breakpointChanged, sizeChanged);
        updateDebugIndicator();
      };
      
      // Initial update
      updateDebugIndicator();
    }
    
    // Add debug indicator
    addResponsiveDebugIndicator();
    
    // === RESPONSIVE LAYOUT CALCULATION FUNCTIONS (Phase 3) ===
    
    // Calculate responsive layout parameters
    function calculateResponsiveLayout() {
      const canvas = currentCanvasDimensions;
      const layout = canvas.layout;
      
      let layoutParams = {
        // Canvas dimensions
        canvasWidth: canvas.width,
        canvasHeight: canvas.height,
        
        // Layout type
        layout: layout,
        
        // Centers and spacing
        leftCenter: { x: 0, y: 0 },
        rightCenter: { x: 0, y: 0 },
        
        // Scaling factors
        scaleFactor: 1,
        
        // Layout-specific parameters
        spacing: 0,
        padding: 0
      };
      
      if (layout === 'stacked') {
        // Mobile: Stack vertically
        layoutParams.leftCenter = {
          x: canvas.width / 2,
          y: canvas.height * 0.3 // Top third for main animation
        };
        layoutParams.rightCenter = {
          x: canvas.width / 2,
          y: canvas.height * 0.7 // Bottom third for six clusters
        };
        layoutParams.scaleFactor = Math.min(canvas.width / 1400, canvas.height / 700) * 0.8;
        layoutParams.spacing = canvas.height * 0.4; // Vertical spacing
        layoutParams.padding = 20;
        
      } else if (layout === 'hybrid') {
        // Tablet: Hybrid layout with some horizontal space
        const leftWidth = canvas.width * 0.6;
        const rightWidth = canvas.width * 0.4;
        
        layoutParams.leftCenter = {
          x: leftWidth / 2,
          y: canvas.height / 2
        };
        layoutParams.rightCenter = {
          x: leftWidth + (rightWidth / 2),
          y: canvas.height / 2
        };
        layoutParams.scaleFactor = Math.min(canvas.width / 1400, canvas.height / 700) * 0.9;
        layoutParams.spacing = canvas.width * 0.6;
        layoutParams.padding = 30;
        
      } else {
        // Desktop: Dual layout (lg, xl, 2xl)
        layoutParams.leftCenter = {
          x: canvas.width / 4, // Left quarter
          y: canvas.height / 2
        };
        layoutParams.rightCenter = {
          x: (canvas.width * 3) / 4, // Right quarter
          y: canvas.height / 2
        };
        layoutParams.scaleFactor = Math.min(canvas.width / 1400, canvas.height / 700);
        layoutParams.spacing = canvas.width / 2;
        layoutParams.padding = 40;
      }
      
      // Ensure minimum scale factor
      layoutParams.scaleFactor = Math.max(layoutParams.scaleFactor, 0.3);
      
      console.log(`📐 Layout calculated for ${currentBreakpoint}:`, {
        layout: layoutParams.layout,
        leftCenter: layoutParams.leftCenter,
        rightCenter: layoutParams.rightCenter,
        scaleFactor: layoutParams.scaleFactor.toFixed(2),
        spacing: layoutParams.spacing.toFixed(0)
      });
      
      return layoutParams;
    }
    
    // Get current responsive layout parameters
    let currentLayoutParams = calculateResponsiveLayout();
    
    // Update layout parameters when responsive state changes
    function updateResponsiveLayout() {
      currentLayoutParams = calculateResponsiveLayout();
      console.log(`🎯 Layout updated for ${currentBreakpoint} breakpoint`);
      return currentLayoutParams;
    }
    
    // Helper functions for responsive positioning
    function getResponsiveCenterX(side = 'left') {
      return side === 'left' ? currentLayoutParams.leftCenter.x : currentLayoutParams.rightCenter.x;
    }
    
    function getResponsiveCenterY(side = 'left') {
      const baseY = side === 'left' ? currentLayoutParams.leftCenter.y : currentLayoutParams.rightCenter.y;
      const offset = getResponsiveCenterYOffset();
      
      // Apply stacked layout specific offsets if in stacked layout
      if (isStackedLayout()) {
        const stackedOffset = side === 'left' ? getResponsiveLeftAnimationYOffset() : getResponsiveRightAnimationYOffset();
        return baseY + offset + stackedOffset;
      }
      
      return baseY + offset;
    }
    
    function getResponsiveScaleFactor() {
      return currentLayoutParams.scaleFactor;
    }
    
    function getResponsiveSpacing() {
      return currentLayoutParams.spacing;
    }
    
    function getResponsivePadding() {
      return currentLayoutParams.padding;
    }
    
    function isStackedLayout() {
      return currentLayoutParams.layout === 'stacked';
    }
    
    function isDualLayout() {
      return currentLayoutParams.layout === 'dual';
    }
    
    // Helper functions for responsive left-side animation sizing
    function getResponsiveLeftBallSizeMultiplier() {
      const config = RESPONSIVE_CONFIG.breakpoints[currentBreakpoint];
      return config.leftBallSizeMultiplier;
    }
    
    function getResponsiveLeftLargeBallMultiplier() {
      const config = RESPONSIVE_CONFIG.breakpoints[currentBreakpoint];
      return config.leftLargeBallMultiplier;
    }
    
    // Helper function for responsive center Y offset
    function getResponsiveCenterYOffset() {
      const config = RESPONSIVE_CONFIG.breakpoints[currentBreakpoint];
      return config.centerYOffset || 0;
    }
    
    // Helper functions for stacked layout positioning
    function getResponsiveLeftAnimationYOffset() {
      const config = RESPONSIVE_CONFIG.breakpoints[currentBreakpoint];
      return config.leftAnimationYOffset || 0;
    }
    
    function getResponsiveRightAnimationYOffset() {
      const config = RESPONSIVE_CONFIG.breakpoints[currentBreakpoint];
      return config.rightAnimationYOffset || 0;
    }
    
    function getResponsiveLeftTitleYOffset() {
      const config = RESPONSIVE_CONFIG.breakpoints[currentBreakpoint];
      return config.leftTitleYOffset || 0;
    }
    
    function getResponsiveRightTitleYOffset() {
      const config = RESPONSIVE_CONFIG.breakpoints[currentBreakpoint];
      return config.rightTitleYOffset || 0;
    }
    
    // Initialize responsive system after all responsive configs are defined
    setupResponsiveMonitoring();

    // === Generate circles with proper circle packing and spacing control ===
    let packedNodes;
    
     if (CONFIG.USE_ABSOLUTE_SIZING) {
       // Create circles with variable absolute sizes and random positioning
       // First, create an array of indices and shuffle it to randomize large ball positions
       const indices = Array.from({ length: CONFIG.BALL_COUNT }, (_, i) => i);
       const shuffledIndices = indices.sort(() => Math.random() - 0.5);
       
       packedNodes = Array.from({ length: CONFIG.BALL_COUNT }, (_, i) => {
         const isLarge = shuffledIndices[i] < CONFIG.LARGE_BALL_COUNT;
        
        // Variable radius within the size category with responsive multipliers
        let baseRadius;
        if (isLarge) {
          baseRadius = CONFIG.LARGE_BALL_MIN_RADIUS + 
                      Math.random() * (CONFIG.LARGE_BALL_MAX_RADIUS - CONFIG.LARGE_BALL_MIN_RADIUS);
        } else {
          baseRadius = CONFIG.SMALL_BALL_MIN_RADIUS + 
                      Math.random() * (CONFIG.SMALL_BALL_MAX_RADIUS - CONFIG.SMALL_BALL_MIN_RADIUS);
        }
        
        // Apply responsive sizing multipliers
        const sizeMultiplier = getResponsiveLeftBallSizeMultiplier();
        const largeMultiplier = isLarge ? getResponsiveLeftLargeBallMultiplier() : 1;
        const radius = baseRadius * sizeMultiplier * largeMultiplier;
        
        // Better initial positioning to avoid all starting at center
        const angle = Math.random() * 2 * Math.PI;
        const distance = Math.random() * 200 + 50; // Random distance from center (50-250px)
        const centerX = getResponsiveCenterX('left');
        const centerY = getResponsiveCenterY('left');
        const x = centerX + Math.cos(angle) * distance;
        const y = centerY + Math.sin(angle) * distance;
        
        return {
          x: x,
          y: y,
          r: radius,
          value: isLarge ? 1 : 0.1 // Large balls get higher value for packing
        };
      });
    } else {
      // Use D3's pack algorithm (original behavior)
      const data = { children: Array.from({ length: CONFIG.BALL_COUNT }, () => ({ value: Math.random() })) };

    const pack = d3.pack()
        .size([CONFIG.CANVAS_SIZE * 0.8, CONFIG.CANVAS_SIZE * 0.8])
        .padding(0); // No padding in pack algorithm

    const root = d3.hierarchy(data).sum(d => d.value);
      packedNodes = pack(root).leaves();
      
      // Apply size multiplier and set radius based on mode with responsive multipliers
      packedNodes.forEach(node => {
        node.r *= CONFIG.BALL_SIZE_MULTIPLIER;
        
        // Apply responsive sizing multiplier
        const sizeMultiplier = getResponsiveLeftBallSizeMultiplier();
        node.r *= sizeMultiplier;
        
        if (CONFIG.USE_FIXED_SIZE) {
          // All balls same size
          node.r = CONFIG.FIXED_BALL_RADIUS * sizeMultiplier;
        } else {
          // Variable sizes constrained to min/max bounds
          node.r = Math.max(CONFIG.MIN_BALL_RADIUS * sizeMultiplier, Math.min(CONFIG.MAX_BALL_RADIUS * sizeMultiplier, node.r));
        }
      });
    }
    
    // Position circles appropriately based on sizing mode
    let nodes;
    
    if (CONFIG.USE_ABSOLUTE_SIZING) {
      // For absolute sizing, start all circles at center and let force simulation position them
      const centerX = getResponsiveCenterX('left');
      const centerY = getResponsiveCenterY('left');
      nodes = packedNodes.map(node => ({
        ...node,
        x: centerX,
        y: centerY,
        targetX: centerX,
        targetY: centerY,
        vx: 0,
        vy: 0
      }));
    } else {
      // For packed sizing, center the packed layout using responsive centers
      const bounds = d3.extent(packedNodes, d => d.x - d.r);
      const boundsY = d3.extent(packedNodes, d => d.y - d.r);
      const minX = bounds[0];
      const minY = boundsY[0];
      const maxX = d3.extent(packedNodes, d => d.x + d.r)[1];
      const maxY = d3.extent(packedNodes, d => d.y + d.r)[1];
      
      const layoutWidth = maxX - minX;
      const layoutHeight = maxY - minY;
      const centerX = getResponsiveCenterX('left');
      const centerY = getResponsiveCenterY('left');
      const offsetX = centerX - (minX + layoutWidth / 2);
      const offsetY = centerY - (minY + layoutHeight / 2);
      
      // Create final nodes with target positions
      nodes = packedNodes.map(node => ({
        ...node,
        x: node.x + offsetX,
        y: node.y + offsetY,
        targetX: node.x + offsetX,
        targetY: node.y + offsetY,
        vx: 0,
        vy: 0
      }));
    }

    const svg = d3.select("#viz");

    // === Create separate groups for each visualization ===
    const mainAnimationGroup = svg.append("g").attr("id", "main-animation");

    // === Animation variables ===
    let currentNodes = [];
    let simulation = null;
    let circles = null;
    let lines = null;
    let frameCount = 0;
    let lastFrameTime = 0;
    let animationId = null;


    // === Force simulation setup ===
    function createSimulation(nodes) {
      return d3.forceSimulation(nodes)
        .force("charge", d3.forceManyBody().strength(CONFIG.CHARGE_STRENGTH))
        .force("collision", d3.forceCollide().radius(d => d.r + CONFIG.COLLISION_PADDING))
        .force("pack", packForce(nodes))
        .force("center", weakCenterForce()) // Custom weak center force
        .alphaDecay(CONFIG.ALPHA_DECAY)
        .on("tick", updateVisualization)
        .velocityDecay(0.4);
    }

    // === Custom weak center force (Mike Bostock approach) ===
    function weakCenterForce() {
      return function() {
        // Don't apply force if animation is complete
        if (leftAnimationComplete) return;
        
        const centerX = getResponsiveCenterX('left');
        const centerY = getResponsiveCenterY('left');
        const strength = 0.01; // Very weak force
        
        currentNodes.forEach(node => {
          const dx = centerX - node.x;
          const dy = centerY - node.y;
          
          // Apply force everywhere to prevent center hole
          node.vx += dx * strength;
          node.vy += dy * strength;
        });
      };
    }

    // === Custom force to move toward packed positions (with progressive weakening) ===
    function packForce(nodes) {
      return function() {
        // Progressive weakening: start strong, end weak
        const alpha = simulation ? simulation.alpha() : 1;
        const strength = CONFIG.PACK_FORCE_STRENGTH * alpha; // Weaken over time
        
        nodes.forEach(node => {
          if (node.targetX !== undefined && node.targetY !== undefined) {
            const dx = node.targetX - node.x;
            const dy = node.targetY - node.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Only apply force if ball is far from target and simulation is active
            if (distance > 20 && alpha > 0.1) {
              node.vx += dx * strength;
              node.vy += dy * strength;
            }
          }
        });
      };
    }

    // === Optimized visualization update with frame rate limiting ===
    function updateVisualization() {
      // Don't update if left animation is complete (frozen)
      if (leftAnimationComplete) return;
      
      frameCount++;
      
      // Skip frames for better performance
      if (frameCount % CONFIG.FRAME_SKIP !== 0) return;
      
      const now = performance.now();
      const deltaTime = now - lastFrameTime;
      
      // Target 60 FPS = ~16.67ms per frame
      if (deltaTime < 1000 / CONFIG.TARGET_FPS) return;
      
      lastFrameTime = now;
      
      // Update circles (always needed)
      if (circles) {
        circles
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);
      }
      
      // Update lines only if enabled and not too many
      if (CONFIG.ENABLE_LINES && lines && lines.size() <= CONFIG.MAX_LINES) {
        lines
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);
      }
    }

    // === Add new ball and trigger simulation ===
    function addBall() {
      if (currentNodes.length >= nodes.length) {
        // All balls added, start final settlement phase
        startFinalSettlement();
        return;
      }

      // Add new node at responsive center with target packed position
      const centerX = getResponsiveCenterX('left');
      const centerY = getResponsiveCenterY('left');
      const newNode = {
        ...nodes[currentNodes.length],
        x: centerX, // start at responsive center
        y: centerY, // start at responsive center
        targetX: nodes[currentNodes.length].x, // packed position
        targetY: nodes[currentNodes.length].y, // packed position
        vx: 0,
        vy: 0
      };
      currentNodes.push(newNode);

      // Update target positions for all existing nodes to their packed positions
      currentNodes.forEach((node, i) => {
        node.targetX = nodes[i].x;
        node.targetY = nodes[i].y;
      });

      // Update circles
      circles = mainAnimationGroup.selectAll("circle")
        .data(currentNodes)
        .join("circle")
      .attr("cx", d => d.x)
      .attr("cy", d => d.y)
      .attr("r", d => d.r)
        .attr("fill", "none")
        .attr("stroke", CONFIG.STROKE_COLOR)
        .attr("stroke-width", CONFIG.STROKE_WIDTH);

      // Update lines (connect new ball to all existing balls) - only if enabled
      if (CONFIG.ENABLE_LINES) {
        const links = [];
        const maxLinks = Math.min(CONFIG.MAX_LINES, (currentNodes.length * (currentNodes.length - 1)) / 2);
        
        // Create links more efficiently
        for (let i = 0; i < currentNodes.length && links.length < maxLinks; i++) {
          for (let j = i + 1; j < currentNodes.length && links.length < maxLinks; j++) {
            links.push({ source: currentNodes[i], target: currentNodes[j] });
          }
        }

        lines = mainAnimationGroup.selectAll("line")
          .data(links)
          .join("line")
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y)
          .attr("stroke", CONFIG.LINE_COLOR)
          .attr("stroke-width", CONFIG.LINE_WIDTH)
          .attr("opacity", CONFIG.LINE_OPACITY);
      }

      // Create new simulation with updated nodes
      if (simulation) simulation.stop();
      simulation = createSimulation(currentNodes);
      
      // Run simulation for a bit, then add next ball
      simulation.alpha(1).restart();
      
      setTimeout(() => {
        simulation.stop();
        addBall();
      }, CONFIG.BALL_APPEAR_DELAY);
    }

    // === Final settlement phase (Mike Bostock approach) ===
    function startFinalSettlement() {
      console.log("Starting final settlement phase...");
      
      // Create final simulation with all nodes
      if (simulation) simulation.stop();
      simulation = createSimulation(currentNodes);
      
      // Remove pack force for natural settling
      simulation.force("pack", null);
      
      // Use moderate energy for gentle final settling
      simulation.alpha(0.3).restart();
      
      // Let it run for configured time for final settlement
      setTimeout(() => {
        if (simulation) {
          simulation.stop();
          // Remove all forces to prevent further movement
          simulation.force("charge", null);
          simulation.force("collision", null);
          simulation.force("pack", null);
          simulation.force("center", null);
        }
        console.log("Final settlement complete - animation frozen!");
        leftAnimationComplete = true;
        
        // Show left side text and start right animation after delay
        showLeftSideText();
        setTimeout(() => {
          startRightSideAnimation();
        }, 1000); // 1 second delay
      }, CONFIG.FINAL_SETTLEMENT_TIME);
    }

    // === Performance monitoring ===
    function logPerformance() {
      const fps = Math.round(1000 / (performance.now() - lastFrameTime));
      console.log(`FPS: ${fps}, Balls: ${currentNodes.length}, Lines: ${lines ? lines.size() : 0}`);
    }

    // === Start the animation ===
    addBall();
    
    // Log performance every 2 seconds
    setInterval(logPerformance, 2000);

    // === Animation State Management ===
    let leftAnimationComplete = false;
    let rightAnimationComplete = false;

    // === Text Display Functions ===
    function showLeftSideText() {
      const centerX = getResponsiveCenterX('left');
      const centerY = getResponsiveCenterY('left');
      const scaleFactor = getResponsiveScaleFactor();
      const fontSize = Math.max(16, 24 * scaleFactor);
      const config = RESPONSIVE_CONFIG.breakpoints[currentBreakpoint];
      
      // Calculate text offset using responsive configuration
      let textOffset;
      if (isStackedLayout()) {
        // For stacked layouts, use multiplier relative to center
        textOffset = centerY + (centerY * config.textOffset);
        // Apply stacked layout title offset
        textOffset += getResponsiveLeftTitleYOffset();
      } else {
        // For dual/hybrid layouts, use percentage of canvas height
        textOffset = centerY + (currentCanvasDimensions.height * config.textOffset);
      }
      
      // Ensure text stays within canvas bounds
      textOffset = Math.min(textOffset, currentCanvasDimensions.height - 20);
      
      console.log(`📝 Left text positioning:`, {
        breakpoint: currentBreakpoint,
        centerY: centerY,
        canvasHeight: currentCanvasDimensions.height,
        textOffset: textOffset,
        fontSize: fontSize,
        configTextOffset: config.textOffset
      });
      
      mainAnimationGroup.append("text")
        .attr("x", centerX)
        .attr("y", textOffset)
        .attr("text-anchor", "middle")
        .attr("font-family", "Outfit, sans-serif")
        .attr("font-size", `${fontSize}px`)
        .attr("font-weight", "600")
        .attr("fill", CONFIG.STROKE_COLOR)
        .text("Traditional Node distribution");
    }

    function showRightSideText() {
      const centerX = getResponsiveCenterX('right');
      const centerY = getResponsiveCenterY('right');
      const scaleFactor = getResponsiveScaleFactor();
      const fontSize = Math.max(16, 24 * scaleFactor);
      const config = RESPONSIVE_CONFIG.breakpoints[currentBreakpoint];
      
      // Calculate text offset using responsive configuration
      let textOffset;
      if (isStackedLayout()) {
        // For stacked layouts, use multiplier relative to center
        textOffset = centerY + (centerY * config.textOffset);
      } else {
        // For dual/hybrid layouts, use percentage of canvas height
        textOffset = centerY + (currentCanvasDimensions.height * config.textOffset);
      }
      
      // Ensure text stays within canvas bounds
      textOffset = Math.min(textOffset, currentCanvasDimensions.height - 20);
      
      console.log(`📝 Right text positioning:`, {
        breakpoint: currentBreakpoint,
        centerY: centerY,
        canvasHeight: currentCanvasDimensions.height,
        textOffset: textOffset,
        fontSize: fontSize,
        configTextOffset: config.textOffset
      });
      
      sixClusterGroup.append("text")
        .attr("x", centerX)
        .attr("y", textOffset)
        .attr("text-anchor", "middle")
        .attr("font-family", "Outfit, sans-serif")
        .attr("font-size", `${fontSize}px`)
        .attr("font-weight", "600")
        .attr("fill", CONFIG.STROKE_COLOR)
        .text("Cerebral Node distribution");
    }

    // === Right-Side Animation Function ===
    function startRightSideAnimation() {
      console.log("Starting right-side cluster animation...");
      
      // Animate clusters appearing one by one
      sixClusters.forEach((cluster, clusterIndex) => {
        setTimeout(() => {
          // Animate cluster balls appearing
          cluster.balls.forEach((ball, ballIndex) => {
            setTimeout(() => {
              const clusterGroup = sixClusterGroup.select(`.cluster-${cluster.id}`);
              
              // Animate circle growing from radius 0
              clusterGroup.selectAll("circle")
                .filter((d, i) => i === ballIndex) // Select the specific ball
                .transition()
                .duration(300)
                .attr("r", ball.r)
                .style("opacity", 1);
              
              // Animate lines appearing
              if (CONFIG.ENABLE_LINES && ballIndex > 0) {
                // Connect to previous balls in same cluster
                for (let i = 0; i < ballIndex; i++) {
                  const prevBall = cluster.balls[i];
                  const lineIndex = ballIndex * (ballIndex - 1) / 2 + i; // Calculate line index
                  
                  clusterGroup.selectAll("line")
                    .filter((d, idx) => idx === lineIndex) // Select the specific line
                    .transition()
                    .duration(200)
                    .attr("x2", ball.x)
                    .attr("y2", ball.y)
                    .style("opacity", CONFIG.LINE_OPACITY);
                }
              }
            }, ballIndex * 150); // 150ms delay between balls
          });
          
          // Add inter-cluster lines after cluster is complete
          if (clusterIndex === sixClusters.length - 1) {
            setTimeout(() => {
              addInterClusterLines();
              showRightSideText();
              rightAnimationComplete = true;
              console.log("Right-side animation complete!");
            }, cluster.balls.length * 150 + 500);
          }
        }, clusterIndex * 1000); // 1 second delay between clusters
      });
    }

    function addInterClusterLines() {
      if (CONFIG.ENABLE_LINES) {
        const interLinks = [];
        for (let i = 0; i < CONFIG.NUM_CLUSTERS; i++) {
          for (let j = i + 1; j < CONFIG.NUM_CLUSTERS; j++) {
            interLinks.push({ 
              source: { x: sixClusters[i].centerX, y: sixClusters[i].centerY },
              target: { x: sixClusters[j].centerX, y: sixClusters[j].centerY }
            });
          }
        }
        
        sixClusterGroup.selectAll("line.inter-cluster")
          .data(interLinks)
          .join("line")
          .attr("class", "inter-cluster")
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.source.x) // Start from source
          .attr("y2", d => d.source.y) // Start from source
          .attr("stroke", CONFIG.STROKE_COLOR)
          .attr("stroke-width", CONFIG.LINE_WIDTH * 2)
          .attr("opacity", 0)
          .transition()
          .duration(400)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y)
          .style("opacity", CONFIG.LINE_OPACITY * 0.8);
      }
    }

    // === Six-Cluster Layout (Right Side) ===
    function createSixClusters() {
      const clusters = [];
      let ballId = CONFIG.BALL_COUNT; // Start ID after main animation balls
      
      for (let i = 0; i < CONFIG.NUM_CLUSTERS; i++) {
        // Fixed number of balls per cluster (all clusters same)
        const numBalls = CONFIG.BALLS_PER_CLUSTER;
        
        // Get responsive configuration for cluster sizing
        const config = RESPONSIVE_CONFIG.breakpoints[currentBreakpoint];
        
        // Create balls for this cluster with responsive size
        const clusterBalls = Array.from({ length: numBalls }, () => {
          return {
            id: ballId++,
            value: 1, // Fixed value for uniform size
            clusterId: i,
            r: config.clusterBallSize // Responsive radius for all right-side balls
          };
        });
        
        // Calculate cluster center position (radial layout around right side center)
        const angle = (i * 2 * Math.PI) / CONFIG.NUM_CLUSTERS;
        const rightCenterX = getResponsiveCenterX('right');
        const rightCenterY = getResponsiveCenterY('right');
        const scaleFactor = getResponsiveScaleFactor();
        const clusterRadius = config.clusterRadius * scaleFactor;
        const centerX = rightCenterX + Math.cos(angle) * clusterRadius;
        const centerY = rightCenterY + Math.sin(angle) * clusterRadius;
        
        clusters.push({
          id: i,
          balls: clusterBalls,
          centerX: centerX,
          centerY: centerY
        });
      }
      
      return clusters;
    }

    // Generate six clusters
    const sixClusters = createSixClusters();

    // Pack each cluster independently with responsive sizing
    const scaleFactor = getResponsiveScaleFactor();
    const packConfig = RESPONSIVE_CONFIG.breakpoints[currentBreakpoint];
    sixClusters.forEach(cluster => {
      const packSize = packConfig.clusterPackSize * scaleFactor;
      const pack = d3.pack()
        .size([packSize, packSize])
        .padding(2);
      
      const root = d3.hierarchy({ children: cluster.balls }).sum(d => d.value);
      const packedBalls = pack(root).leaves();
      
      // Update cluster balls with packed positions (keep fixed radius)
      packedBalls.forEach((packedBall, i) => {
        const ball = cluster.balls[i];
        ball.x = packedBall.x + cluster.centerX - packSize / 2;
        ball.y = packedBall.y + cluster.centerY - packSize / 2;
        // Keep the fixed radius we set earlier
        // ball.r remains CONFIG.RIGHT_CLUSTER_BALL_SIZE
      });
    });

    // Create separate SVG group for six clusters to avoid conflicts
    const sixClusterGroup = svg.append("g").attr("id", "six-clusters");

    // Setup cluster groups and render circles (hidden initially)
    function setupClusterGroups() {
      sixClusters.forEach(cluster => {
        const clusterGroup = sixClusterGroup.append("g").attr("class", `cluster-${cluster.id}`);
        
        // Render all circles but hide them initially
        clusterGroup.selectAll("circle")
          .data(cluster.balls)
          .join("circle")
          .attr("cx", d => d.x)
          .attr("cy", d => d.y)
          .attr("r", 0) // Start with radius 0
          .attr("fill", "none")
          .attr("stroke", CONFIG.STROKE_COLOR)
          .attr("stroke-width", CONFIG.STROKE_WIDTH)
          .style("opacity", 0); // Hidden initially
          
        // Render intra-cluster lines but hide them initially
        if (CONFIG.ENABLE_LINES) {
          const links = [];
          for (let i = 0; i < cluster.balls.length; i++) {
            for (let j = i + 1; j < cluster.balls.length; j++) {
              links.push({ source: cluster.balls[i], target: cluster.balls[j] });
            }
          }
          
          clusterGroup.selectAll("line")
            .data(links)
            .join("line")
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.source.x) // Start from source
            .attr("y2", d => d.source.y) // Start from source
            .attr("stroke", CONFIG.LINE_COLOR)
            .attr("stroke-width", CONFIG.LINE_WIDTH)
            .attr("opacity", 0)
            .style("opacity", 0); // Hidden initially
        }
      });
    }

    // Debug: Log cluster positions with responsive configuration
    const debugConfig = RESPONSIVE_CONFIG.breakpoints[currentBreakpoint];
    console.log(`📊 Six clusters created for ${currentBreakpoint}:`, {
      clusters: sixClusters.length,
      ballsPerCluster: CONFIG.BALLS_PER_CLUSTER,
      ballSize: debugConfig.clusterBallSize,
      clusterRadius: debugConfig.clusterRadius,
      packSize: debugConfig.clusterPackSize,
      scaleFactor: scaleFactor.toFixed(2)
    });
    sixClusters.forEach((cluster, i) => {
      console.log(`Cluster ${i}: center (${cluster.centerX.toFixed(1)}, ${cluster.centerY.toFixed(1)}), balls: ${cluster.balls.length}`);
      if (cluster.balls.length > 0) {
        console.log(`  First ball: x=${cluster.balls[0].x.toFixed(1)}, y=${cluster.balls[0].y.toFixed(1)}, r=${cluster.balls[0].r}`);
      }
    });

    // Setup cluster groups (will be animated in later)
    setupClusterGroups();

    // === Download logic ===
    document.getElementById("downloadBtn").addEventListener("click", () => {
      const serializer = new XMLSerializer();
      const svgNode = document.getElementById("viz");
      const source = serializer.serializeToString(svgNode);

      const blob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(blob);

      const link = document.createElement("a");
      link.href = url;
      link.download = "circle-packing.svg";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>