<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Circle Packing Export</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body { 
      font-family: 'Outfit', sans-serif; 
      text-align: center; 
      margin: 2rem; 
      background: #f8f9fa;
    }
    #viz { 
      border: 1px solid #ccc; 
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    button { 
      margin-top: 1rem; 
      padding: 0.5rem 1rem; 
      font-size: 1rem; 
      font-family: 'Outfit', sans-serif;
      background: #0A61B5;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #0851a0;
    }
    #status-text {
      font-size: 1.2rem;
      font-weight: 500;
      color: #333;
      text-anchor: middle;
      dominant-baseline: middle;
    }
    .status-commit { color: #e74c3c; }
    .status-verify { color: #f39c12; }
    .status-execute { color: #27ae60; }
    .status-idle { color: #7f8c8d; }
  </style>
</head>
<body>
 
  <svg id="viz" width="1400" height="700"></svg>
  <br>
  <button id="downloadBtn">Download SVG</button>

  <script>
    // === Animation Configuration ===
    const CONFIG = {
      // === GLOBAL SETTINGS (Apply to both clusters) ===
      // Animation timing
      BALL_APPEAR_DELAY: 30, // ms between ball appearances
      FINAL_SETTLEMENT_TIME: 8000, // ms for final settlement phase
      
      // Force simulation parameters
      CHARGE_STRENGTH: -50, // Repulsion between balls
      PACK_FORCE_STRENGTH: 0.8, // Strength of pack force (increased to compensate for removed center force)
      COLLISION_PADDING: 2, // Extra padding around balls for collision
      ALPHA_DECAY: 0.02, // How fast simulation slows down
      
      // Initial energy control
      INITIAL_ALPHA: 0.4, // Initial simulation energy (0-1, lower = less energy)
      VELOCITY_DECAY: 0.4, // How fast velocity decreases (0-1, higher = more damping)
      INITIAL_VELOCITY_X: 0, // Initial X velocity for new balls
      INITIAL_VELOCITY_Y: 0, // Initial Y velocity for new balls
      
      // Visual settings
      STROKE_WIDTH: 2,
      LINE_WIDTH: 0.5,
      LINE_OPACITY: 0.3,
      STROKE_COLOR: "#0A61B5",
      LINE_COLOR: "#0A61B5",
      
      // Ball sizing (applies to both clusters)
      BALL_SIZE_MULTIPLIER: 1, // Multiplier for ball sizes (1.0 = original)
      UNIFORM_BALL_SIZES: true, // Toggle: true = all balls same size, false = variable sizes
      FIXED_BALL_RADIUS: 15, // Fixed radius for all balls (when UNIFORM_BALL_SIZES = true)
      MIN_BALL_RADIUS: 14, // Minimum ball radius (when UNIFORM_BALL_SIZES = false)
      MAX_BALL_RADIUS: 20, // Maximum ball radius (when UNIFORM_BALL_SIZES = false)
      
      // Canvas settings
      CANVAS_SIZE: 1400, // Canvas width
      CENTER_X: 700, // Center of canvas
      CENTER_Y: 350, // Center of canvas
      
      // Performance settings
      TARGET_FPS: 60, // Target frames per second
      FRAME_SKIP: 1, // Update every N frames (1 = every frame)
      ENABLE_LINES: true, // Toggle connecting lines for performance
      MAX_LINES: 5000, // Maximum number of lines to draw
      
      // Mouse interaction settings
      MOUSE_REPULSION_STRENGTH: -2, // Strength of mouse repulsion force
      MOUSE_REPULSION_DISTANCE: 25, // Distance at which mouse affects balls
      MOUSE_TOUCH_STRENGTH: -20, // Extra strength when mouse is very close to a ball
      MOUSE_TOUCH_DISTANCE: 15, // Distance for "touching" a ball (stronger force)
      MOUSE_DAMPENING: 0.00001, // Dampening factor for touch strength (0-1, lower = more dampening)
      ENABLE_MOUSE_INTERACTION: true, // Toggle mouse interaction
      
      // Inter-cluster line settings
      INTER_CLUSTER_LINE_WIDTH: 1.5,
      INTER_CLUSTER_LINE_OPACITY: 0.6,
      INTER_CLUSTER_LINE_COLOR: "#4885CA",
      INTER_CLUSTER_LINE_DASH: "1,2", // Dashed line pattern
      
      // === CLUSTERS SETTINGS (Centered) ===
      NUM_CLUSTERS: 5, // Number of small clusters
      MIN_BALLS_PER_CLUSTER: 8, // Minimum balls per small cluster
      MAX_BALLS_PER_CLUSTER: 8, // Maximum balls per small cluster
      BALL_PADDING: 1, // Padding between balls in small clusters
      CLUSTER_RADIUS: 200, // Distance from center for cluster centers
      CLUSTER_PACK_SIZE: 120, // Size for individual cluster packing
      
    };

    // === DAG Overlay Configuration ===
    CONFIG.DAG = {
      OUT_DEGREE: 2,          // how many forward edges per cluster (acyclic)
      CURVE: 0.25,            // 0..0.6, bend amount for link curves
      ARROW_SIZE: 6,          // arrowhead size (px)
      EDGE_COLOR: "#0A61B5",
      EDGE_WIDTH: 1.5,
      EDGE_OPACITY: 0.7,
      HIGHLIGHT_COLOR: "#1a8cff",
      HIGHLIGHT_WIDTH: 3,
      TOKEN_RADIUS: 4,
      STEP_MS: 4000           // interval between demo transactions
    };

    // === Generate clusters centered on screen ===
    
    // Create clusters (centered)
    const clusters = [];
    let ballId = 0; // Start ID from 0
    
    for (let i = 0; i < CONFIG.NUM_CLUSTERS; i++) {
      // Number of balls per cluster (uniform)
      const numBalls = CONFIG.MIN_BALLS_PER_CLUSTER; // Since MIN = MAX = 6
      
      // Create balls for this cluster
      const clusterBalls = Array.from({ length: numBalls }, () => {
        let ballValue;
        if (CONFIG.UNIFORM_BALL_SIZES) {
          ballValue = 1; // Same value for uniform sizes
        } else {
          ballValue = Math.random(); // Random value for variable sizes
        }
        
        return {
          id: ballId++,
          value: ballValue,
          clusterId: i
        };
      });
      
      clusters.push({
        id: i,
        balls: clusterBalls,
        centerX: 0, // Will be calculated
        centerY: 0, // Will be calculated
        isOriginal: false
      });
    }
    
    // Calculate radial positions for cluster centers (centered on screen)
    clusters.forEach((cluster, i) => {
      const angle = (i * 2 * Math.PI) / CONFIG.NUM_CLUSTERS;
      cluster.centerX = CONFIG.CENTER_X + CONFIG.CLUSTER_RADIUS * Math.cos(angle);
      cluster.centerY = CONFIG.CENTER_Y + CONFIG.CLUSTER_RADIUS * Math.sin(angle);
    });
    
    // Fix a topological order by angle around the global center; used to keep DAG acyclic
    const topoOrder = d3.range(CONFIG.NUM_CLUSTERS).sort((a, b) => {
      const ax = clusters[a].centerX - CONFIG.CENTER_X;
      const ay = clusters[a].centerY - CONFIG.CENTER_Y;
      const bx = clusters[b].centerX - CONFIG.CENTER_X;
      const by = clusters[b].centerY - CONFIG.CENTER_Y;
      return Math.atan2(ay, ax) - Math.atan2(by, bx);
    });
    const topoIndex = new Map(topoOrder.map((id, i) => [id, i]));

    // Build DAG edges (indices strictly increase; no wrap)
    function computeDAGEdges() {
      const edges = [];
      for (let i = 0; i < topoOrder.length; i++) {
        const src = topoOrder[i];
        for (let k = 1; k <= CONFIG.DAG.OUT_DEGREE; k++) {
          const j = i + k;
          if (j < topoOrder.length) {
            edges.push({ source: src, target: topoOrder[j] });
          }
        }
      }
      return edges;
    }
    const DAG_EDGES = computeDAGEdges();

    // Pack each cluster individually
    const allNodes = [];
    
    // Pack clusters (centered)
    clusters.forEach(cluster => {
      // Create hierarchy for this cluster
      const clusterData = { children: cluster.balls };
    const pack = d3.pack()
        .size([CONFIG.CLUSTER_PACK_SIZE, CONFIG.CLUSTER_PACK_SIZE])
        .padding(CONFIG.BALL_PADDING);
      
      const root = d3.hierarchy(clusterData).sum(d => d.value);
      const packedBalls = pack(root).leaves();
      
      // Apply size multiplier and offset to cluster center
      const smallPackedCenterX = CONFIG.CLUSTER_PACK_SIZE / 2; // 60
      const smallPackedCenterY = CONFIG.CLUSTER_PACK_SIZE / 2; // 60
      
      packedBalls.forEach(ball => {
        // Apply size multiplier first
        ball.r *= CONFIG.BALL_SIZE_MULTIPLIER;
        
        // Apply radius based on uniform/variable size setting
        if (CONFIG.UNIFORM_BALL_SIZES) {
          ball.r = CONFIG.FIXED_BALL_RADIUS; // All balls same size
        } else {
          const minRadius = CONFIG.MIN_BALL_RADIUS;
          const maxRadius = CONFIG.MAX_BALL_RADIUS;
          const sizeRange = maxRadius - minRadius;
          ball.r = minRadius + (ball.value * sizeRange); // Variable sizes
        }
        
        // Center the packed layout properly around the desired centerpoint
        ball.x = ball.x - smallPackedCenterX + cluster.centerX;
        ball.y = ball.y - smallPackedCenterY + cluster.centerY;
        ball.clusterId = cluster.id;
        ball.targetX = ball.x;
        ball.targetY = ball.y;
        ball.vx = 0;
        ball.vy = 0;
      });
      
      allNodes.push(...packedBalls);
    });
    
    const nodes = allNodes;

    const svg = d3.select("#viz");

    // === DAG Overlay SVG Layers ===
    // Layering
    const gInter = svg.append("g").attr("id", "intercluster"); // for DAG overlay
    const gEdges = gInter.append("g").attr("class", "edges");
    const gAnim  = gInter.append("g").attr("class", "anim");
    
    // Status text element inside SVG
    const statusText = svg.append("text")
      .attr("id", "status-text")
      .attr("x", CONFIG.CENTER_X)
      .attr("y", 650) // Position near bottom of canvas (700 - 50)
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "middle")
      .attr("font-family", "Outfit, sans-serif")
      .attr("font-size", "1.2rem")
      .attr("font-weight", "500")
      .attr("fill", "#7f8c8d")
      .text("Ready to start transaction...");

    // Arrowhead marker definition
    const defs = svg.append("defs");
    defs.append("marker")
      .attr("id", "arrowhead")
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 10)
      .attr("refY", 5)
      .attr("markerWidth", CONFIG.DAG.ARROW_SIZE)
      .attr("markerHeight", CONFIG.DAG.ARROW_SIZE)
      .attr("orient", "auto-start-reverse")
      .append("path")
      .attr("d", "M 0 0 L 10 5 L 0 10 z")
      .attr("fill", CONFIG.DAG.EDGE_COLOR)
      .attr("opacity", CONFIG.DAG.EDGE_OPACITY);

    // === Animation variables ===
    let currentNodes = [];
    let simulation = null;
    let circles = null;
    let lines = null;
    let frameCount = 0;
    let lastFrameTime = 0;
    let animationId = null;
    
    // === Mouse interaction variables ===
    let mouseX = CONFIG.CANVAS_SIZE / 2; // Start at canvas center
    let mouseY = CONFIG.CENTER_Y;
    let isMouseOverCanvas = false;


    // === Force simulation setup ===
    function createSimulation(nodes) {
      const sim = d3.forceSimulation(nodes)
        .force("charge", d3.forceManyBody().strength(CONFIG.CHARGE_STRENGTH))
        .force("collision", d3.forceCollide().radius(d => d.r + CONFIG.BALL_PADDING))
        .force("pack", packForce(nodes))
        .alphaDecay(CONFIG.ALPHA_DECAY) // Slower decay for more settling time
        .on("tick", updateVisualization)
        .velocityDecay(CONFIG.VELOCITY_DECAY); // Configurable velocity decay
        
      // Add mouse repulsion force if enabled
      if (CONFIG.ENABLE_MOUSE_INTERACTION) {
        sim.force("mouse", mouseRepulsionForce());
      }
      
      return sim;
    }

    // === Custom force to move toward packed positions ===
    function packForce(nodes) {
      return function() {
        nodes.forEach(node => {
          if (node.targetX !== undefined && node.targetY !== undefined) {
            const dx = node.targetX - node.x;
            const dy = node.targetY - node.y;
            node.vx += dx * CONFIG.PACK_FORCE_STRENGTH;
            node.vy += dy * CONFIG.PACK_FORCE_STRENGTH;
          }
        });
      };
    }

    // === Mouse repulsion force ===
    function mouseRepulsionForce() {
      return function() {
        if (!isMouseOverCanvas) return;
        
        currentNodes.forEach(node => {
          const dx = node.x - mouseX;
          const dy = node.y - mouseY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Only apply force if within repulsion distance
          if (distance < CONFIG.MOUSE_REPULSION_DISTANCE && distance > 0) {
            // Calculate force strength: 0% at max distance, 100% at 0 distance
            const normalizedDistance = distance / CONFIG.MOUSE_REPULSION_DISTANCE;
            const forceMultiplier = 1 - normalizedDistance; // 0 at max distance, 1 at 0 distance
            
            let baseForce;
            
            // Check if mouse is "touching" the ball (very close)
            if (distance < CONFIG.MOUSE_TOUCH_DISTANCE) {
              // Use stronger touch force for very close interactions
              baseForce = CONFIG.MOUSE_TOUCH_STRENGTH;
              
              // Apply dampening to prevent extreme forces at very close distances
              const touchDampening = Math.pow(forceMultiplier, CONFIG.MOUSE_DAMPENING);
              baseForce *= touchDampening;
            } else {
              // Use normal repulsion force for medium distance
              baseForce = CONFIG.MOUSE_REPULSION_STRENGTH;
            }
            
            // Apply linear force scaling
            const force = baseForce * forceMultiplier;
            
            const fx = (dx / distance) * force;
            const fy = (dy / distance) * force;
            
            node.vx += fx;
            node.vy += fy;
          }
        });
      };
    }

    // === Compute cluster statistics (centroid + radius) ===
    function computeClusterStats(nodesArr) {
      const map = new Map(); // clusterId -> {cx, cy, R}
      const grouped = d3.group(nodesArr, d => d.clusterId);
      grouped.forEach((arr, cid) => {
        const cx = d3.mean(arr, d => d.x);
        const cy = d3.mean(arr, d => d.y);
        // radius ~ furthest circle edge from centroid + margin
        let R = 0;
        arr.forEach(n => {
          const dist = Math.hypot(n.x - cx, n.y - cy) + n.r;
          if (dist > R) R = dist;
        });
        R += 8; // small margin
        map.set(+cid, { id: +cid, cx, cy, R });
      });
      return map;
    }

    // === Geometry helpers for curved arrow paths ===
    function rimPoint(A, B) { // point on rim of A facing B
      const ang = Math.atan2(B.cy - A.cy, B.cx - A.cx);
      return { x: A.cx + Math.cos(ang) * A.R, y: A.cy + Math.sin(ang) * A.R };
    }

    function linkPath(A, B) {
      const p1 = rimPoint(A, B);
      const p2 = rimPoint(B, A);
      const mx = (p1.x + p2.x) / 2, my = (p1.y + p2.y) / 2;
      const dx = p2.x - p1.x, dy = p2.y - p1.y;
      const L  = Math.hypot(dx, dy) || 1;
      // Perp normal for curvature
      const nx = -dy / L, ny = dx / L;
      const bend = CONFIG.DAG.CURVE * L;  // proportional bend
      const cx = mx + nx * bend, cy = my + ny * bend;
      return `M${p1.x},${p1.y} Q${cx},${cy} ${p2.x},${p2.y}`;
    }

    // === DAG Overlay Renderer ===
    function drawDAGOverlay(nodesArr) {
      const stats = computeClusterStats(nodesArr);
      
      // Debug: Log cluster stats and DAG edges
      console.log("Cluster stats:", stats);
      console.log("DAG edges:", DAG_EDGES);
      
      // Filter out edges where cluster stats are missing
      const data = DAG_EDGES.map(e => ({
        e,
        A: stats.get(e.source),
        B: stats.get(e.target)
      })).filter(d => d.A && d.B); // Only include edges where both clusters exist
      
      console.log("Filtered data:", data);

      const paths = gEdges.selectAll("path.dag")
        .data(data, d => `${d.e.source}-${d.e.target}`);

      paths.enter()
        .append("path")
        .attr("class", "dag")
        .attr("fill", "none")
        .attr("stroke", CONFIG.DAG.EDGE_COLOR)
        .attr("stroke-width", CONFIG.DAG.EDGE_WIDTH)
        .attr("opacity", CONFIG.DAG.EDGE_OPACITY)
        .attr("marker-end", "url(#arrowhead)")
        .merge(paths)
        .attr("d", d => linkPath(d.A, d.B));

      paths.exit().remove();
    }

    // === Demo Animation Functions ===
    function updateStatusText(text, color = '#7f8c8d') {
      statusText
        .text(text)
        .attr("fill", color);
    }

    function pickTransactionTriple() {
      // choose source < intermediary < destination by topo order to respect DAG direction
      const ids = topoOrder.slice();
      const i1 = Math.floor(Math.random() * (ids.length - 2));
      const i2 = i1 + 1 + Math.floor(Math.random() * (ids.length - i1 - 1)); // at least +1
      const i3 = i2 + 1 + Math.floor(Math.random() * (ids.length - i2 - 1)); // at least +1
      if (i3 >= ids.length) return pickTransactionTriple(); // retry until valid triple
      return { src: ids[i1], mid: ids[i2], dst: ids[i3] };
    }

    function animateAlong(pathSel, duration, onEnd) {
      // draw a moving token along a given path
      const path = pathSel.node();
      const L = path.getTotalLength();
      const token = gAnim.append("circle")
        .attr("r", CONFIG.DAG.TOKEN_RADIUS)
        .attr("fill", CONFIG.DAG.HIGHLIGHT_COLOR);

      d3.transition()
        .duration(duration)
        .tween("move", () => t => {
          const p = path.getPointAtLength(t * L);
          token.attr("cx", p.x).attr("cy", p.y);
        })
        .on("end", () => { token.remove(); onEnd && onEnd(); });
    }

    function pulseCluster(stats, id) {
      gAnim.append("circle")
        .attr("cx", stats.get(id).cx)
        .attr("cy", stats.get(id).cy)
        .attr("r", stats.get(id).R)
        .attr("fill", "none")
        .attr("stroke", CONFIG.DAG.HIGHLIGHT_COLOR)
        .attr("stroke-width", 2)
        .attr("opacity", 0.8)
        .transition()
        .duration(600)
        .attr("stroke-width", 0.5)
        .attr("opacity", 0)
        .remove();
    }

    function runDemoTransaction() {
      const active = currentNodes.length ? currentNodes : nodes;
      const stats = computeClusterStats(active);
      const triple = pickTransactionTriple();

      // Find the two path selections (src→mid, mid→dst)
      const findPath = (a, b) =>
        gEdges.selectAll("path.dag")
          .filter(d => d.e.source === a && d.e.target === b);

      const p1 = findPath(triple.src, triple.mid);
      const p2 = findPath(triple.mid, triple.dst);

      // If missing (shouldn't, but guard), skip and retry next tick
      if (p1.empty() || p2.empty()) return;

      // Step 1: Commit (source pulse + token to intermediary)
      updateStatusText(`COMMIT: Starting transaction from cluster ${triple.src}`, '#e74c3c');
      pulseCluster(stats, triple.src);
      setTimeout(() => {
        animateAlong(p1, 2000, () => {
          // Step 2: Verify (intermediary pulse), then to destination
          updateStatusText(`VERIFY: Validating at cluster ${triple.mid}`, '#f39c12');
          pulseCluster(stats, triple.mid);
          setTimeout(() => {
            animateAlong(p2, 2000, () => {
              // Step 3: Execute (destination pulse + global sync pulses for all three)
              updateStatusText(`EXECUTE: Completing at cluster ${triple.dst}`, '#27ae60');
              pulseCluster(stats, triple.dst);
              setTimeout(() => {
                updateStatusText(`SYNC: All clusters synchronized`, '#27ae60');
                pulseCluster(stats, triple.src);
                pulseCluster(stats, triple.mid);
                pulseCluster(stats, triple.dst);
                
                // Reset to idle after sync - much longer delay
                setTimeout(() => {
                  updateStatusText(`Waiting for next transaction...`, '#7f8c8d');
                }, 5000); // 5 seconds for idle message
              }, 5000); // 5 seconds for SYNC message
            });
          }, 5000); // 5 seconds for VERIFY message
        });
      }, 5000); // 5 seconds for COMMIT message
    }

    // === Optimized visualization update with frame rate limiting ===
    function updateVisualization() {
      frameCount++;
      
      // Skip frames for better performance
      if (frameCount % CONFIG.FRAME_SKIP !== 0) return;
      
      const now = performance.now();
      const deltaTime = now - lastFrameTime;
      
      // Target 60 FPS = ~16.67ms per frame
      if (deltaTime < 1000 / CONFIG.TARGET_FPS) return;
      
      lastFrameTime = now;
      
      // Update circles (always needed)
      if (circles) {
        circles
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);
      }
      
      // Update lines only if enabled and not too many
      if (CONFIG.ENABLE_LINES && lines && lines.size() <= CONFIG.MAX_LINES) {
        lines
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);
      }
      
      // Update DAG overlay during animation
      drawDAGOverlay(currentNodes.length ? currentNodes : nodes);
    }

    // === Add new ball to existing simulation ===
    function addBall() {
      if (currentNodes.length >= nodes.length) {
        // All balls added, start final settlement phase
        startFinalSettlement();
        return;
      }

      // Add new node at screen center with target packed position
      const targetNode = nodes[currentNodes.length];
      const newNode = {
        ...targetNode,
        x: CONFIG.CENTER_X,      // Screen center
        y: CONFIG.CENTER_Y,      // Screen center
        targetX: targetNode.x,   // packed position
        targetY: targetNode.y,   // packed position
        vx: CONFIG.INITIAL_VELOCITY_X, // Configurable initial X velocity
        vy: CONFIG.INITIAL_VELOCITY_Y  // Configurable initial Y velocity
      };
      currentNodes.push(newNode);

      // Update target positions for all existing nodes to their packed positions
      currentNodes.forEach((node, i) => {
        node.targetX = nodes[i].x;
        node.targetY = nodes[i].y;
      });

      // Update circles
      circles = svg.selectAll("circle")
        .data(currentNodes)
        .join("circle")
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
        .attr("r", d => d.r)
        .attr("fill", "none")
        .attr("stroke", CONFIG.STROKE_COLOR)
        .attr("stroke-width", CONFIG.STROKE_WIDTH);

      // Update lines
      if (CONFIG.ENABLE_LINES) {
        const links = [];
        
        // Group nodes by cluster
        const nodesByCluster = {};
        currentNodes.forEach(node => {
          if (!nodesByCluster[node.clusterId]) {
            nodesByCluster[node.clusterId] = [];
          }
          nodesByCluster[node.clusterId].push(node);
        });
        
        // Create links for each cluster (connect within each cluster)
        Object.entries(nodesByCluster).forEach(([clusterId, clusterNodes]) => {
          for (let i = 0; i < clusterNodes.length; i++) {
            for (let j = i + 1; j < clusterNodes.length; j++) {
              links.push({ 
                source: clusterNodes[i], 
                target: clusterNodes[j] 
              });
            }
          }
        });

        lines = svg.selectAll("line")
          .data(links)
          .join("line")
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y)
          .attr("stroke", CONFIG.LINE_COLOR)
          .attr("stroke-width", CONFIG.LINE_WIDTH)
          .attr("opacity", CONFIG.LINE_OPACITY);
      }

      // Update DAG overlay
      drawDAGOverlay(currentNodes);

      // Update the existing simulation with new nodes (don't restart)
      if (simulation) {
        simulation.nodes(currentNodes);
        simulation.alpha(CONFIG.INITIAL_ALPHA).restart();
      } else {
        // Create simulation only on first ball
        simulation = createSimulation(currentNodes);
        simulation.alpha(CONFIG.INITIAL_ALPHA).restart();
      }
      
      // Schedule next ball addition without stopping simulation
      setTimeout(() => {
        addBall();
      }, CONFIG.BALL_APPEAR_DELAY);
    }



    // === Final settlement phase ===
    function startFinalSettlement() {
      console.log("Starting final settlement phase...");
      
      // Create final simulation with all nodes
      if (simulation) simulation.stop();
      simulation = createSimulation(currentNodes);
      
      // Run for much longer with stronger pack force
      simulation.alpha(0.8).restart(); // Use high but not maximum energy for final settlement
      
      // Let it run for configured time for final settlement
      setTimeout(() => {
        if (simulation) simulation.stop();
        console.log("Final settlement complete!");
      }, CONFIG.FINAL_SETTLEMENT_TIME);
    }

    // === Performance monitoring ===
    function logPerformance() {
      const fps = Math.round(1000 / (performance.now() - lastFrameTime));
      console.log(`FPS: ${fps}, Balls: ${currentNodes.length}, Lines: ${lines ? lines.size() : 0}`);
    }

    // === Static rendering (no animation) ===
    function renderStaticClusters() {
      // Render all circles
      circles = svg.selectAll("circle")
      .data(nodes)
        .join("circle")
      .attr("cx", d => d.x)
      .attr("cy", d => d.y)
      .attr("r", d => d.r)
        .attr("fill", "none")
        .attr("stroke", CONFIG.STROKE_COLOR)
        .attr("stroke-width", CONFIG.STROKE_WIDTH);

      // Render lines only within each cluster
      if (CONFIG.ENABLE_LINES) {
        const links = [];
        
        // Group nodes by cluster
        const nodesByCluster = {};
        nodes.forEach(node => {
          if (!nodesByCluster[node.clusterId]) {
            nodesByCluster[node.clusterId] = [];
          }
          nodesByCluster[node.clusterId].push(node);
        });
        
        // Create links only within each cluster
        Object.entries(nodesByCluster).forEach(([clusterId, clusterNodes]) => {
          for (let i = 0; i < clusterNodes.length; i++) {
            for (let j = i + 1; j < clusterNodes.length; j++) {
              links.push({ 
                source: clusterNodes[i], 
                target: clusterNodes[j] 
              });
            }
          }
        });

        lines = svg.selectAll("line")
          .data(links)
          .join("line")
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y)
          .attr("stroke", CONFIG.LINE_COLOR)
          .attr("stroke-width", CONFIG.LINE_WIDTH)
          .attr("opacity", CONFIG.LINE_OPACITY);
      }

      // Render DAG overlay
      drawDAGOverlay(nodes);
    }



    // === Mouse event listeners ===
    svg.on("mousemove", function(event) {
      const rect = this.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
      isMouseOverCanvas = true;
      
      // Restart simulation to apply mouse force
      if (simulation && CONFIG.ENABLE_MOUSE_INTERACTION) {
        simulation.alpha(0.3).restart();
      }
    });
    
    svg.on("mouseleave", function() {
      isMouseOverCanvas = false;
    });
    
    svg.on("mouseenter", function() {
      isMouseOverCanvas = true;
    });

    // === Start the animation ===
    addBall();
    
    console.log(`Starting animation with ${nodes.length} balls in ${CONFIG.NUM_CLUSTERS} clusters`);

    // === Initialize status text ===
    updateStatusText(`Initializing DAG overlay with ${CONFIG.NUM_CLUSTERS} clusters...`, '#7f8c8d');

    // === Start demo animation loop ===
    // Total cycle time: 5s (COMMIT) + 2s (token1) + 5s (VERIFY) + 2s (token2) + 5s (EXECUTE) + 5s (SYNC) + 5s (IDLE) = 29s
    setInterval(runDemoTransaction, 29000);

    // === Download logic ===
    document.getElementById("downloadBtn").addEventListener("click", () => {
      const serializer = new XMLSerializer();
      const svgNode = document.getElementById("viz");
      const source = serializer.serializeToString(svgNode);

      const blob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(blob);

      const link = document.createElement("a");
      link.href = url;
      link.download = "circle-packing.svg";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>